# Zend Memory Manager

Zend Memory Manager (часто сокращается как ZendMM или ZMM) - это слой C, предназначенный для выделения и освобождения динамической памяти, связанной с запросами.

Обратите внимание на "связанной с запросами" в приведённом выше предложении.

ZendMM - это не просто классический слой поверх распределителя динамической памяти libc, в основном представленный парой API вызовов `malloc()/free()`. ZendMM - это о связанной с запросами памятью, которую PHP должен выделять во время запроса.

#### Два основных вида динамического пула в PHP.

PHP - это архитектура, не требующая совместного использования. Ну, не на все 100%. Позвольте нам объяснить.

_<mark style="background-color:orange;">Примечание: Возможно, вам стоит прочитать главу о жизненном цикле PHP, прежде чем продолжить, т.к. вы получите дополнительную информацию о различных процессах во время выполнения PHP.</mark>_

PHP может обрабатывать несколько сотен или тысяч запросов в одном и том же процессе и по умолчанию забудет о каждом после выполнения.&#x20;

Под "забудет" подразумевается освобождение любого динамического буфера, выделенного при обработке запроса. Это значит, что в процессе обработки запроса, нельзя распределять динамическую память с помощью традиционных вызовов libc. Делать подобное совершенно правильно, но вы даёте возможность забыть освободить такой буфер. ZendMM поставляется с API, который заменяет динамический распределитель libc, копируя его API. В процессе обработки запроса программист должен использовать этот API вместо распределителя libc.&#x20;

ZendMM поставляется с API, который заменяет libc распределитель, копируя его API. В процессе обработки запроса программист должен использовать этот API вместо libc распределителя.

Например, когда PHP обрабатывает запрос, он анализирует PHP файлы. Те, которые приведут к объявлению классов и функций, например. Когда компилятор начинает компилировать PHP файлы, он будет распределять некоторую динамическую память для хранения классов и функций, которые он обнаружит. Но в конце запроса PHP забудет о них. По умолчанию, PHP забывает огромное количество информации от одного запроса к другому.

Однако существует довольно редкая информация, которую нужно сохранять в  нескольких запросах. Но это исключения.

Что можно было бы оставить неизменным посредством запросов? То, что мы называем постоянными объектами (persistence objects). Ещё раз: это за редким исключением. Например, текущий путь к исполняемому файлу PHP не будет меняться от запроса к запросу. Последняя информация выделяется постоянно - это значит, что она выделяется с помощью традиционного вызова malloc() libc.&#x20;

Что же ещё? Пару строк. Например, строка "_\_SERVER_" будет переиспользоваться от запроса к запросу, каждый из которых будет создавать переменную $\_SERVER. Таким образом, строка $\_SERVER может быть выделена постоянно, потому что её выделили однажды.

_**Что вы должны запомнить:**_

Существует два вида распределения динамической памяти при разработки ядра PHP и расширений:

* Динамические распределения, которые привязаны к запросу.
* Постоянные динамические распределения.

Динамическое распределение памяти с привязкой к запросу:

* Должно выполняться только тогда, когда PHP обрабатывает запрос (ни до, ни после).
* Должно выполняться только с использованием API динамического выделения памяти ZendMM.
* Очень распространены в дизайне расширений, в основном 95% ваших динамических распределений будут привязаны к запросам.
* Отслеживаются ZendMM, так что вы будете проинформированы об утечке.

Постоянное динамическое распределение памяти:

* Не нужно выполнять, пока PHP обрабатывает запрос (не запрещено, но идея плохая).
* Не отслеживается ZendMM, поэтому вы не будете проинформированы об утечке.
* Довольно редко встречается в расширениях.&#x20;
