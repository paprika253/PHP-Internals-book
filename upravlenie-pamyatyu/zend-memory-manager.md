# Zend Memory Manager

Zend Memory Manager (часто сокращается как ZendMM или ZMM) - это слой C, предназначенный для выделения и освобождения динамической памяти, связанной с запросами.

Обратите внимание на "связанной с запросами" в приведённом выше предложении.

ZendMM - это не просто классический слой поверх распределителя динамической памяти libc, в основном представленный парой API вызовов `malloc()/free()`. ZendMM - это о связанной с запросами памятью, которую PHP должен выделять во время запроса.

#### Два основных вида динамического пула в PHP.

PHP - это архитектура, не требующая совместного использования. Ну, не на все 100%. Позвольте нам объяснить.

_<mark style="background-color:orange;">Примечание: Возможно, вам стоит прочитать главу о жизненном цикле PHP, прежде чем продолжить, т.к. вы получите дополнительную информацию о различных процессах во время выполнения PHP.</mark>_

PHP может обрабатывать несколько сотен или тысяч запросов в одном и том же процессе и по умолчанию забудет о каждом после выполнения.&#x20;

Под "забудет" подразумевается освобождение любого динамического буфера, выделенного при обработке запроса. Это значит, что в процессе обработки запроса, нельзя распределять динамическую память с помощью традиционных вызовов libc. Делать подобное совершенно правильно, но вы даёте возможность забыть освободить такой буфер. ZendMM поставляется с API, который заменяет динамический распределитель libc, копируя его API. В процессе обработки запроса программист должен использовать этот API вместо распределителя libc.&#x20;

ZendMM поставляется с API, который заменяет libc распределитель, копируя его API. В процессе обработки запроса программист должен использовать этот API вместо libc распределителя.

Например, когда PHP обрабатывает запрос, он анализирует PHP файлы. Те, которые приведут к объявлению классов и функций, например. Когда компилятор начинает компилировать PHP файлы, он будет распределять некоторую динамическую память для хранения классов и функций, которые он обнаружит. Но в конце запроса PHP забудет о них. По умолчанию, PHP забывает огромное количество информации от одного запроса к другому.

Однако существует довольно редкая информация, которую нужно сохранять в  нескольких запросах. Но это исключения.

Что можно было бы оставить неизменным посредством запросов? То, что мы называем постоянными объектами (persistence objects). Ещё раз: это за редким исключением. Например, текущий путь к исполняемому файлу PHP не будет меняться от запроса к запросу. Последняя информация выделяется постоянно - это значит, что она выделяется с помощью традиционного вызова malloc() libc.&#x20;

Что же ещё? Пару строк. Например, строка "_\_SERVER_" будет переиспользоваться от запроса к запросу, каждый из которых будет создавать переменную $\_SERVER. Таким образом, строка $\_SERVER может быть выделена постоянно, потому что её выделили однажды.

_**Что вы должны запомнить:**_

Существует два вида распределения динамической памяти при разработки ядра PHP и расширений:

* Динамические распределения, которые привязаны к запросу.
* Постоянные динамические распределения.

Динамическое распределение памяти с привязкой к запросу:

* Должно выполняться только тогда, когда PHP обрабатывает запрос (ни до, ни после).
* Должно выполняться только с использованием API динамического выделения памяти ZendMM.
* Очень распространены в дизайне расширений, в основном 95% ваших динамических распределений будут привязаны к запросам.
* Отслеживаются ZendMM, так что вы будете проинформированы об утечке.

Постоянное динамическое распределение памяти:

* Не нужно выполнять, пока PHP обрабатывает запрос (не запрещено, но идея плохая).
* Не отслеживается ZendMM, поэтому вы не будете проинформированы об утечке.
* Довольно редко встречается в расширениях.&#x20;

Также вы должны знать, что все исходный код PHP был основан на таком уровне памяти. Таким образом, многие внутренние структуры выделяются с помощью ZendMM. Большинство из них получили "постоянный" вызов API, которые при использовании приводят к традиционному libc распределителю памяти.

Вот [zend\_string](https://www.phpinternalsbook.com/php7/internal\_types/strings/zend\_strings.html) строка, привязанная к запросу:

```phpdoc
zend_string *foo = zend_string_init("foo", strlen("foo"), 0);
```

А вот постоянно выделенная:

```phpdoc
zend_string *foo = zend_string_init("foo", strlen("foo"), 1);
```

То же самое для [хэш-таблицы](https://www.phpinternalsbook.com/php7/internal\_types/hashtables.html):

```phpdoc
zend_array ar;
zend_hash_init(&ar, 8, NULL, NULL, 0);
```

Постоянно выделенная:

```phpdoc
zend_array ar;
zend_hash_init(&ar, 8, NULL, NULL, 1);
```

Это во всех Zend API интерфейсах. Обычно вопрос обстоит в том, передавать ли "0" в качестве последнего параметра, чтобы обозначить "Я хочу, чтобы эта структура была выполнена с помощью ZendMM, поэтому запрос привязан", или "1", означающий "Я хочу, чтобы структура была выполнена в обход ZendMM и использовала традиционные вызовы `malloc()`libc".

Очевидно, что те структуры обеспечивают API, который запоминает, как ему выделить структуру, чтобы при уничтожении использовать правильную функцию освобождения. Вот пример:

```phpdoc
zend_string_release(foo);
zend_hash_destroy(&ar);
```

API знает, были ли эти структуры выделены с использованием распределения, связанного с запросом, или постоянного, и в первом случае будет использовать `efree()` для его освобождения, а во втором случае libc `free()`.\


## Zend Memory Manager API

API расположено в [Zend/zend\_alloc.h](https://github.com/php/php-src/blob/c3b910370c5c92007c3e3579024490345cb7f9a7/Zend/zend\_alloc.h).\
Вызовы API - это в основном макросы C, так что будьте готовы, если вы их отлаживаете и хотите понаблюдать как они работают. Эти вызовы являются копией libc вызовов, они обычно прибавляют к названию функции букву 'e'; Так что вы не должны теряться, т.к. в API не так много подробностей.

В основном это то, что вы будете использовать довольно часто - `emalloc(size_t)` и `efree(void *)`.

Также вам предоставляется `ecalloc(size_t nmemb, size_t size)`, который выделяет `nmemb` индивидуальный размер `size` и обнуляет область. Если вы сильный C разработчик с опытом, то вам стоит знать когда это возможно, это лучше для использования `ecalloc()` вместо `emalloc()`, так как `ecalloc()` обнулит область памяти, что может сильно помочь в обнаружении ошибок указателя. Запомните, что `emalloc()` работает в основном так же, как и `malloc()`: он будет искать достаточно большую площадь в пулах и возвращать вам более подходящий. Следовательно, вам может быть предоставлен переработанный указатель, который укажет на мусор.&#x20;

Затем следует `safe_emalloc(size_t nmemb, size_t size, size_t offset)`, который представляет собой `emalloc(size * nmemb + offset)`, но проверяет на переполнение для вас. Вам стоит использовать данный API вызов, если номера, которые вы должны предоставить, предоставлены из ненадежного источника, например пользовательской стороны.

Что касается строковых средств, `estrdup(char *)` и `estrndup(char *, size_t len)` позволяют дублировать строки или бинарные строки.

Что бы не случилось, указатель, возвращаемые ZendMM, должны быть освобождены с помощью ZendMM, который `efree()`, а не libc `free()`.

_<mark style="background-color:orange;">Примечание: Примечание о постоянных распределениях. Постоянные распределения остаются активными между запросами. Обычно вы используете libc</mark> <mark style="background-color:orange;"></mark><mark style="background-color:orange;">`malloc/free`</mark><mark style="background-color:orange;">, чтобы выполнить это, но у ZendMM есть несколько ярлыков для libc распределенителей: "постоянное" API. Это API начинается с буквы "p" и дает вам выбор между ZendMM и постоянным распределителем. Следовательно,</mark> <mark style="background-color:orange;"></mark><mark style="background-color:orange;">`pemalloc(size_t, 1)`</mark><mark style="background-color:orange;">, это не что иное, как</mark> <mark style="background-color:orange;"></mark><mark style="background-color:orange;">`malloc()`</mark><mark style="background-color:orange;">,</mark> <mark style="background-color:orange;"></mark><mark style="background-color:orange;">`free(void *, 1)`</mark> <mark style="background-color:orange;"></mark><mark style="background-color:orange;">-</mark> <mark style="background-color:orange;"></mark><mark style="background-color:orange;">`это free()`</mark><mark style="background-color:orange;">, а</mark> <mark style="background-color:orange;"></mark><mark style="background-color:orange;">`pstrdup(void *, 1)`</mark> <mark style="background-color:orange;"></mark><mark style="background-color:orange;">- это</mark> <mark style="background-color:orange;"></mark><mark style="background-color:orange;">`strdup()`</mark><mark style="background-color:orange;">.</mark>_ <mark style="background-color:orange;"></mark><mark style="background-color:orange;"></mark>&#x20;

\
