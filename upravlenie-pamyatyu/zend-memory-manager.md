# Zend Memory Manager

Zend Memory Manager (часто сокращается как ZendMM или ZMM) - это слой C, предназначенный для выделения и освобождения динамической памяти, связанной с запросами.

Обратите внимание на "связанной с запросами" в приведённом выше предложении.

ZendMM - это не просто классический слой поверх распределителя динамической памяти libc, в основном представленный парой API вызовов `malloc()/free()`. ZendMM - это о связанной с запросами памятью, которую PHP должен выделять во время запроса.

#### Два основных вида динамического пула в PHP.

PHP - это архитектура, не требующая совместного использования. Ну, не на все 100%. Позвольте нам объяснить.

_<mark style="background-color:orange;">Примечание: Возможно, вам стоит прочитать главу о жизненном цикле PHP, прежде чем продолжить, т.к. вы получите дополнительную информацию о различных процессах во время выполнения PHP.</mark>_

PHP может обрабатывать несколько сотен или тысяч запросов в одном и том же процессе и по умолчанию забудет о каждом после выполнения.&#x20;

Под "забудет" подразумевается освобождение любого динамического буфера, выделенного при обработке запроса. Это значит, что в процессе обработки запроса, нельзя распределять динамическую память с помощью традиционных вызовов libc. Делать подобное совершенно правильно, но вы даёте возможность забыть освободить такой буфер. ZendMM поставляется с API, который заменяет динамический распределитель libc, копируя его API. В процессе обработки запроса программист должен использовать этот API вместо распределителя libc.&#x20;

ZendMM поставляется с API, который заменяет libc распределитель, копируя его API. В процессе обработки запроса программист должен использовать этот API вместо libc распределителя.

Например, когда PHP обрабатывает запрос, он анализирует PHP файлы. Те, которые приведут к объявлению классов и функций, например. Когда компилятор начинает компилировать PHP файлы, он будет распределять некоторую динамическую память для хранения классов и функций, которые он обнаружит. Но в конце запроса PHP забудет о них. По умолчанию, PHP забывает огромное количество информации от одного запроса к другому.

Однако существует довольно редкая информация, которую нужно сохранять в  нескольких запросах. Но это исключения.

Что можно было бы оставить неизменным посредством запросов? То, что мы называем постоянными объектами (persistence objects). Ещё раз: это за редким исключением. Например, текущий путь к исполняемому файлу PHP не будет меняться от запроса к запросу. Последняя информация выделяется постоянно - это значит, что она выделяется с помощью традиционного вызова malloc() libc.&#x20;

Что же ещё? Пару строк. Например, строка "_\_SERVER_" будет переиспользоваться от запроса к запросу, каждый из которых будет создавать переменную $\_SERVER. Таким образом, строка $\_SERVER может быть выделена постоянно, потому что её выделили однажды.

_**Что вы должны запомнить:**_

Существует два вида распределения динамической памяти при разработки ядра PHP и расширений:

* Динамические распределения, которые привязаны к запросу.
* Постоянные динамические распределения.

Динамическое распределение памяти с привязкой к запросу:

* Должно выполняться только тогда, когда PHP обрабатывает запрос (ни до, ни после).
* Должно выполняться только с использованием API динамического выделения памяти ZendMM.
* Очень распространены в дизайне расширений, в основном 95% ваших динамических распределений будут привязаны к запросам.
* Отслеживаются ZendMM, так что вы будете проинформированы об утечке.

Постоянное динамическое распределение памяти:

* Не нужно выполнять, пока PHP обрабатывает запрос (не запрещено, но идея плохая).
* Не отслеживается ZendMM, поэтому вы не будете проинформированы об утечке.
* Довольно редко встречается в расширениях.&#x20;

Также вы должны знать, что все исходный код PHP был основан на таком уровне памяти. Таким образом, многие внутренние структуры выделяются с помощью ZendMM. Большинство из них получили "постоянный" вызов API, которые при использовании приводят к традиционному libc распределителю памяти.

Вот [zend\_string](https://www.phpinternalsbook.com/php7/internal\_types/strings/zend\_strings.html) строка, привязанная к запросу:

```phpdoc
zend_string *foo = zend_string_init("foo", strlen("foo"), 0);
```

А вот постоянно выделенная:

```phpdoc
zend_string *foo = zend_string_init("foo", strlen("foo"), 1);
```

То же самое для [хэш-таблицы](https://www.phpinternalsbook.com/php7/internal\_types/hashtables.html):

```phpdoc
zend_array ar;
zend_hash_init(&ar, 8, NULL, NULL, 0);
```

Постоянно выделенная:

```phpdoc
zend_array ar;
zend_hash_init(&ar, 8, NULL, NULL, 1);
```

Это во всех Zend API интерфейсах. Обычно вопрос обстоит в том, передавать ли "0" в качестве последнего параметра, чтобы обозначить "Я хочу, чтобы эта структура была выполнена с помощью ZendMM, поэтому запрос привязан", или "1", означающий "Я хочу, чтобы структура была выполнена в обход ZendMM и использовала традиционные вызовы `malloc()`libc".

Очевидно, что те структуры обеспечивают API, который запоминает, как ему выделить структуру, чтобы при уничтожении использовать правильную функцию освобождения. Вот пример:

```phpdoc
zend_string_release(foo);
zend_hash_destroy(&ar);
```

API знает, были ли эти структуры выделены с использованием распределения, связанного с запросом, или постоянного, и в первом случае будет использовать `efree()` для его освобождения, а во втором случае libc `free()`.\


